#!/usr/bin/env bash

COMMIT_MSG_FILE=$1
COMMIT_SOURCE=$2
SHA1=$3

# is_triggered_by replaced by build setup, stub for shellcheck:
is_triggered_by() { :; }

if is_triggered_by revert; then
  echo 'nuggit: ToDoOrToUndo'
  echo
  exit 0
fi
if is_triggered_by merge; then
  exit 0
fi
if is_triggered_by rebase; then
  exit 0
fi
if is_triggered_by cherry-pick; then
  exit 0
fi

  # In case of `git commit -m` we need to first write the provided
  # message and only afterwards append our text
if [[ "$COMMIT_SOURCE" == "message" ]]; then
  cat << EOF
nuggit: ShortMessageService

# Diff to a different commit

To see the difference between your current working-directory (the files you see in the folder) and a commit, you can add a hash, and also if you want a path (add "--" before the path to tell git that the remaining arguments are paths:
\`\`\`sh
git diff CHAPTER_DIFF_FOLLOW -- show.md
\`\`\`
EOF
  exit 0
fi
# add a nuggit to the commit message
(
  cat <<EOF


This is the tutorial nuggit speaking. I am injecting myself in a few
places (like this one), so if you ever see anything starting with nuggit
in this repo, I injected it and it usually wouldn't be there in a normal
git repo.

Since you might be working on multiple things in parallel and it would
not be very comprehensible to include all changes at once, you can tell
git specifically what you want included in the next snapshot. To see
which changes you have made, but not yet staged for a commit, run a
simple
\`\`\`sh
git diff
\`\`\`
(without \`--staged\` as you would have added when looking at the changes
staged for commit)

nuggit: BigCommitment
EOF

  cat "$COMMIT_MSG_FILE"
) > "$COMMIT_MSG_FILE".tmp
mv "$COMMIT_MSG_FILE".tmp "$COMMIT_MSG_FILE"
